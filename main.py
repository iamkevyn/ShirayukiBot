# /home/ubuntu/jsbot/main.py (MODIFICADO - IGNORA COGS COM ERRO)
import os
import nextcord
from nextcord.ext import commands
from dotenv import load_dotenv
import traceback # Importar o m√≥dulo traceback
import sys # Para sys.exit em caso de erro cr√≠tico
import asyncio # Para wavelink
import wavelink # Para Lavalink
from wavelink.ext import spotify # Para integra√ß√£o Spotify

print("--- Iniciando Bot (Modo Tolerante a Falhas) ---")

# Se estiver usando Replit ou Railway com webserver opcional:
try:
    from keep_alive import keep_alive
    print("-> Tentando iniciar keep_alive...")
    keep_alive()
    print("-> keep_alive iniciado (se aplic√°vel).")
except ImportError:
    print("-> M√≥dulo 'keep_alive' n√£o encontrado, ignorando...")
except Exception as e:
    print("‚ùå Erro ao iniciar keep_alive:")
    traceback.print_exc()

# Carregar vari√°veis de ambiente do .env
print("-> Carregando vari√°veis de ambiente...")
load_dotenv()
token = os.getenv("DISCORD_TOKEN")
lava_uri = os.getenv("LAVALINK_URI")
lava_pass = os.getenv("LAVALINK_PASSWORD")
spotify_client_id = os.getenv("SPOTIFY_CLIENT_ID")
spotify_client_secret = os.getenv("SPOTIFY_CLIENT_SECRET")

if not token:
    print("‚ùå CR√çTICO: Token do bot n√£o encontrado! Verifique seu arquivo .env ou as vari√°veis de ambiente no Railway.")
    sys.exit(1) # Parar execu√ß√£o se o token n√£o for encontrado

if not lava_uri or not lava_pass:
    print("‚ö†Ô∏è AVISO: Credenciais do Lavalink (LAVALINK_URI, LAVALINK_PASSWORD) n√£o encontradas. A funcionalidade de m√∫sica n√£o funcionar√°.")
if not spotify_client_id or not spotify_client_secret:
    print("‚ö†Ô∏è AVISO: Credenciais do Spotify (SPOTIFY_CLIENT_ID, SPOTIFY_CLIENT_SECRET) n√£o encontradas. A busca por links do Spotify pode n√£o funcionar corretamente.")

print("-> Vari√°veis de ambiente carregadas.")

# Intents recomendadas
print("-> Configurando Intents...")
intents = nextcord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True
intents.voice_states = True
print("-> Intents configuradas.")

# Inicializa o bot
print("-> Inicializando o Bot...")

class MusicBot(commands.Bot):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # S√≥ tenta conectar ao Lavalink se as credenciais existirem
        if lava_uri and lava_pass:
            self.loop.create_task(self.connect_nodes())
        else:
            print("-> Conex√£o com Lavalink pulada (credenciais ausentes).")

    async def connect_nodes(self):
        """Conecta aos n√≥s Lavalink."""
        await self.wait_until_ready() # Espera o bot estar pronto
        if not lava_uri or not lava_pass:
            print("‚ùå Erro: Credenciais do Lavalink n√£o configuradas. N√£o √© poss√≠vel conectar ao n√≥.")
            return

        print("-> Tentando conectar ao n√≥ Lavalink...")
        # Configurar cliente Spotify para wavelink se as credenciais estiverem dispon√≠veis
        spotify_client = None
        if spotify_client_id and spotify_client_secret:
            spotify_client = spotify.SpotifyClient(
                client_id=spotify_client_id,
                client_secret=spotify_client_secret
            )
            print("-> Cliente Spotify para Wavelink configurado.")
        else:
            print("-> Cliente Spotify para Wavelink n√£o configurado (credenciais ausentes).")

        try:
            node: wavelink.Node = wavelink.Node(
                uri=lava_uri,
                password=lava_pass,
                spotify_client=spotify_client
            )
            await wavelink.NodePool.connect(client=self, nodes=[node])
            print(f"‚úÖ Conectado ao n√≥ Lavalink em {lava_uri}")
        except Exception as e:
            print(f"‚ùå Erro ao conectar ao n√≥ Lavalink:")
            traceback.print_exc()
            print("‚ö†Ô∏è O bot continuar√° funcionando, mas sem recursos de m√∫sica.")

bot = MusicBot(command_prefix="!", intents=intents)
print("-> Bot inicializado.")

@bot.event
async def on_ready():
    print(f"\n‚úÖ {bot.user.name} est√° online e pronto!")
    print("-> Tentando sincronizar comandos slash...")
    try:
        # Sincronizar comandos
        synced = await bot.sync_application_commands()
        if synced is not None:
            print(f"üîÑ Comandos slash sincronizados: {len(synced)} comandos")
        else:
            print("‚ö†Ô∏è A sincroniza√ß√£o retornou None. Verifique se h√° comandos para sincronizar.")
    except Exception as e:
        print(f"‚ùå Erro ao sincronizar comandos slash:")
        traceback.print_exc()
        print("‚ö†Ô∏è O bot continuar√° funcionando, mas os comandos slash podem n√£o estar dispon√≠veis.")
    print("-> Sincroniza√ß√£o de comandos conclu√≠da (ou falhou).")

# Evento Wavelink para status do n√≥
@bot.event
async def on_wavelink_node_ready(node: wavelink.Node):
    print(f"‚úÖ N√≥ Lavalink '{node.identifier}' est√° pronto!")

# Carrega os COGs da pasta 'cogs' com tratamento de erros aprimorado
print("\n--- Carregando COGs (Modo Tolerante a Falhas) ---")
cogs_dir = "./cogs"
if not os.path.isdir(cogs_dir):
    print(f"‚ùå Erro: Diret√≥rio de COGs '{cogs_dir}' n√£o encontrado.")
else:
    try:
        all_files = os.listdir(cogs_dir)
        print(f"-> Arquivos encontrados em '{cogs_dir}': {all_files}")
        cog_files = [f for f in all_files if f.endswith(".py") and not f.startswith("__")]
        print(f"-> Arquivos .py a serem carregados: {cog_files}")
    except Exception as e:
        print(f"‚ùå Erro ao listar arquivos em '{cogs_dir}':")
        traceback.print_exc()
        cog_files = []

    # Listas para acompanhar o status do carregamento
    cogs_loaded = []
    cogs_failed = []

    for filename in cog_files:
        cog_path = f"cogs.{filename[:-3]}"
        print(f"--> Tentando carregar: {cog_path}")
        try:
            bot.load_extension(cog_path)
            print(f"‚úÖ COG carregado com sucesso: {filename}")
            cogs_loaded.append(filename)
        except commands.errors.NoEntryPointError:
            print(f"‚ö†Ô∏è Aviso: {filename} n√£o possui a fun√ß√£o setup() e n√£o pode ser carregado como cog.")
            cogs_failed.append(f"{filename} (sem setup)")
        except commands.errors.ExtensionAlreadyLoaded:
            print(f"‚ö†Ô∏è Aviso: {filename} j√° estava carregado.")
            cogs_loaded.append(filename)  # Consideramos como carregado
        except Exception as e:
            print(f"‚ùå Erro ao carregar {filename}:")
            traceback.print_exc()
            cogs_failed.append(f"{filename} ({type(e).__name__})")
            print(f"‚ö†Ô∏è Ignorando erro e continuando com os pr√≥ximos cogs...")

    # Resumo do carregamento
    loaded_extensions = list(bot.extensions.keys())
    print(f"\n=== RESUMO DO CARREGAMENTO DE COGS ===")
    print(f"-> Total de cogs encontrados: {len(cog_files)}")
    print(f"-> Cogs carregados com sucesso ({len(cogs_loaded)}): {', '.join(cogs_loaded) if cogs_loaded else 'Nenhum'}")
    print(f"-> Cogs que falharam ({len(cogs_failed)}): {', '.join(cogs_failed) if cogs_failed else 'Nenhum'}")
    print(f"-> Extens√µes ativas ({len(loaded_extensions)}): {', '.join(loaded_extensions) if loaded_extensions else 'Nenhuma'}")
    print("=== FIM DO RESUMO ===\n")

# Executa o bot
print("-> Iniciando execu√ß√£o do bot com o token...")
try:
    bot.run(token)
except nextcord.errors.LoginFailure:
    print("‚ùå CR√çTICO: Falha no login - Token inv√°lido. Verifique seu token.")
except Exception as e:
    print("‚ùå Erro cr√≠tico durante a execu√ß√£o do bot:")
    traceback.print_exc()
finally:
    print("--- Bot encerrado ---")
